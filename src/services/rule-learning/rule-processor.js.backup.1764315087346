/**
 * 集成规则处理器
 * 合并规则生成和质量评估流程，减少LLM调用次数
 */

import { buildPrompt } from '../../utils/format/prompt-loader.js';
import { llmJsonParser } from '../../core/llm-json-parser.js';
import { getPerformanceMonitor } from './performance-monitor.js';

/**
 * 集成规则处理器类
 */
export class IntegratedRuleProcessor {
  constructor(llmService) {
    this.llmService = llmService;
    this.ruleCache = new Map(); // 规则缓存
    this.processingCache = new Map(); // 处理中缓存
    this.performanceMonitor = getPerformanceMonitor();
  }

  /**
   * 集成生成和评估规则
   * @param {Object} learningContext - 学习上下文
   * @returns {Promise<Array>} 生成并评估过的规则数组
   */
  async generateAndEvaluateRules(learningContext, sessionId = null) {
    try {
      const cacheKey = this.generateCacheKey(learningContext);
      
      // 检查缓存
      if (this.ruleCache.has(cacheKey)) {
        console.log(`[IntegratedRuleProcessor] 命中缓存，直接返回规则`);
        if (sessionId) {
          this.performanceMonitor.recordCacheHit(sessionId, true);
        }
        return this.ruleCache.get(cacheKey);
      }

      // 记录缓存未命中
      if (sessionId) {
        this.performanceMonitor.recordCacheHit(sessionId, false);
      }

      // 检查是否正在处理中
      if (this.processingCache.has(cacheKey)) {
        console.log(`[IntegratedRuleProcessor] 等待正在进行的处理`);
        return await this.processingCache.get(cacheKey);
      }

      // 创建处理promise
      const processingPromise = this.doGenerateAndEvaluate(learningContext, sessionId);
      this.processingCache.set(cacheKey, processingPromise);

      try {
        const result = await processingPromise;
        this.ruleCache.set(cacheKey, result);
        return result;
      } finally {
        this.processingCache.delete(cacheKey);
      }

    } catch (error) {
      console.error(`[IntegratedRuleProcessor] 集成处理失败: ${error.message}`);
      return [];
    }
  }

  /**
   * 执行生成和评估
   * @param {Object} learningContext - 学习上下文
   * @returns {Promise<Array>} 处理结果
   */
  async doGenerateAndEvaluate(learningContext, sessionId = null) {
    console.log(`[IntegratedRuleProcessor] 开始集成生成和评估规则`);

    // 1. 使用集成提示词一次性完成生成和评估
    const integratedPrompt = this.buildIntegratedPrompt(learningContext);
    
    // 记录LLM调用开始
    const llmStartTime = Date.now();
    
    // 2. 调用LLM
    const llmResult = await this.llmService.call(integratedPrompt);
    
    // 记录LLM调用完成
    const llmDuration = Date.now() - llmStartTime;
    if (sessionId) {
      this.performanceMonitor.recordLLMCall(sessionId, 'integratedGeneration', {
        promptLength: integratedPrompt.length,
        responseLength: llmResult.content?.length || 0,
        duration: llmDuration
      });
    }
    
    // 3. 解析结果
    const parsedResult = this.parseIntegratedResponse(llmResult.content);
    
    if (!parsedResult.success) {
      throw new Error(`集成响应解析失败: ${parsedResult.error}`);
    }

    // 4. 后处理和验证
    const processedRules = await this.postProcessRules(parsedResult.rules, learningContext);
    
    console.log(`[IntegratedRuleProcessor] 集成处理完成: 生成${processedRules.length}条规则`);
    return processedRules;
  }

  /**
   * 构建集成提示词
   * @param {Object} learningContext - 学习上下文
   * @returns {string} 集成提示词
   */
  buildIntegratedPrompt(learningContext) {
    const analysisData = this.formatAnalysisResults(learningContext.currentAnalysis);
    
    return `你是一个SQL规则生成和评估专家。基于以下分析结果，生成高质量的SQL审核规则，并同时评估每条规则的质量。

## 分析上下文
- **数据库类型**: ${learningContext.databaseType}
- **SQL查询**: ${learningContext.sql}
- **分析结果**: ${JSON.stringify(analysisData, null, 2)}

## 任务要求
1. 基于实际分析结果生成规则
2. 每条规则必须包含质量评估
3. 规则必须具体可检测
4. 避免生成重复或低质量规则

## 输出格式
返回一个JSON对象，包含以下结构：
\`\`\`json
{
  "rules": [
    {
      "id": "规则ID",
      "title": "规则标题",
      "category": "performance|security|standards",
      "type": "规则类型(如:索引优化,SQL注入防护,编码规范等)",
      "severity": "critical|high|medium|low",
      "description": "问题描述",
      "condition": "触发条件",
      "confidence": 0.8,
      "example": "SQL示例",
      "recommendation": "修复建议",
      "qualityEvaluation": {
        "qualityScore": 85,
        "qualityLevel": "良好",
        "shouldKeep": true,
        "evaluationSummary": "质量评估摘要"
      }
    }
  ]
}
\`\`\`

请生成规则并评估质量，确保每条规则都有实用价值。`;
  }

  /**
   * 解析集成响应
   * @param {string} content - LLM响应内容
   * @returns {Object} 解析结果
   */
  parseIntegratedResponse(content) {
    try {
      const parseResult = llmJsonParser.parse(content, 'generic');
      
      if (parseResult.success && parseResult.data) {
        const rules = parseResult.data.rules || parseResult.data;
        
        if (Array.isArray(rules)) {
          return {
            success: true,
            rules: rules.filter(rule => this.validateIntegratedRule(rule))
          };
        }
      }
      
      return { success: false, error: '未找到有效规则数据' };
    } catch (error) {
      console.error(`[IntegratedRuleProcessor] 解析失败: ${error.message}`);
      return { success: false, error: error.message };
    }
  }

  /**
   * 验证集成规则
   * @param {Object} rule - 规则对象
   * @returns {boolean} 是否有效
   */
  validateIntegratedRule(rule) {
    const required = ['title', 'category', 'type', 'severity', 'description', 'condition', 'confidence'];
    
    // 检查基本字段
    for (const field of required) {
      if (!rule[field]) return false;
    }
    
    // 检查质量评估
    if (!rule.qualityEvaluation || !rule.qualityEvaluation.qualityScore) {
      return false;
    }
    
    // 检查置信度范围
    if (rule.confidence < 0 || rule.confidence > 1) return false;
    
    // 检查质量分数
    const qualityScore = rule.qualityEvaluation.qualityScore;
    if (qualityScore < 0 || qualityScore > 100) return false;
    
    return true;
  }

  /**
   * 后处理规则
   * @param {Array} rules - 原始规则数组
   * @param {Object} learningContext - 学习上下文
   * @returns {Promise<Array>} 处理后的规则数组
   */
  async postProcessRules(rules, learningContext) {
    const processedRules = [];
    
    for (const rule of rules) {
      try {
        // 添加元数据
        const processedRule = {
          ...rule,
          id: rule.id || this.generateRuleId(),
          databaseType: learningContext.databaseType,
          source: {
            sqlPattern: learningContext.sql,
            analysisContext: learningContext.patterns
          },
          timestamp: new Date().toISOString(),
          // 标准化质量评估
          evaluation: {
            ...rule.qualityEvaluation,
            qualityLevel: this.getQualityLevel(rule.qualityEvaluation.qualityScore),
            llmEvaluation: {
              dimensionScores: {
                accuracy: rule.qualityEvaluation.qualityScore,
                usefulness: rule.qualityEvaluation.qualityScore * 0.9,
                clarity: rule.qualityEvaluation.qualityScore * 0.95
              },
              strengths: [`基于实际分析结果生成`, `置信度: ${rule.confidence}`],
              issues: rule.qualityEvaluation.qualityScore < 70 ? ['质量分数较低，需要审核'] : []
            }
          }
        };
        
        processedRules.push(processedRule);
      } catch (error) {
        console.warn(`[IntegratedRuleProcessor] 规则后处理失败: ${error.message}`);
      }
    }
    
    return processedRules;
  }

  /**
   * 生成规则ID
   * @returns {string} 规则ID
   */
  generateRuleId() {
    return `R-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * 获取质量等级
   * @param {number} score - 质量分数
   * @returns {string} 质量等级
   */
  getQualityLevel(score) {
    if (score >= 90) return '优秀';
    if (score >= 80) return '良好';
    if (score >= 70) return '一般';
    if (score >= 60) return '较差';
    return '很差';
  }

  /**
   * 生成缓存键
   * @param {Object} learningContext - 学习上下文
   * @returns {string} 缓存键
   */
  generateCacheKey(learningContext) {
    const keyData = {
      sql: learningContext.sql.substring(0, 100),
      databaseType: learningContext.databaseType,
      patterns: learningContext.patterns
    };
    return JSON.stringify(keyData);
  }

  /**
   * 格式化分析结果
   * @param {Object} analysisResult - 分析结果
   * @returns {Object} 格式化后的分析结果
   */
  formatAnalysisResults(analysisResult) {
    const formatted = {
      performance: {},
      security: {},
      standards: {}
    };

    try {
      // 格式化性能分析
      if (analysisResult.data?.performance?.data) {
        const perfData = analysisResult.data.performance.data;
        formatted.performance = {
          summary: perfData.summary || '',
          issues: perfData.issues || [],
          recommendations: perfData.recommendations || [],
          confidence: analysisResult.data.performance.metadata?.confidence || 0
        };
      }

      // 格式化安全分析
      if (analysisResult.data?.security?.data) {
        const secData = analysisResult.data.security.data;
        formatted.security = {
          summary: secData.summary || '',
          vulnerabilities: secData.vulnerabilities || [],
          recommendations: secData.recommendations || [],
          confidence: analysisResult.data.security.metadata?.confidence || 0
        };
      }

      // 格式化规范分析
      if (analysisResult.data?.standards?.data) {
        const stdData = analysisResult.data.standards.data;
        formatted.standards = {
          summary: stdData.summary || '',
          violations: stdData.violations || [],
          recommendations: stdData.recommendations || [],
          confidence: analysisResult.data.standards.metadata?.confidence || 0
        };
      }
    } catch (error) {
      console.warn(`[IntegratedRuleProcessor] 分析结果格式化失败: ${error.message}`);
    }

    return formatted;
  }

  /**
   * 清除缓存
   */
  clearCache() {
    this.ruleCache.clear();
    this.processingCache.clear();
    console.log('[IntegratedRuleProcessor] 缓存已清除');
  }

  /**
   * 获取缓存统计
   * @returns {Object} 缓存统计信息
   */
  getCacheStats() {
    return {
      ruleCacheSize: this.ruleCache.size,
      processingCacheSize: this.processingCache.size,
      totalCachedRules: Array.from(this.ruleCache.values()).reduce((sum, rules) => sum + rules.length, 0)
    };
  }
}

export default IntegratedRuleProcessor;