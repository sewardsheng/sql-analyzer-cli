/**
 * è°ƒè¯•æ—¥å¿—æ¸…ç†å·¥å…·
 * è‰¹ï¼è€ç‹è¦æŠŠè¿™äº›SBçš„è°ƒè¯•æ—¥å¿—å…¨éƒ½å¹²æ‰ï¼
 */

import fs from 'fs/promises';
import path from 'path';

/**
 * è°ƒè¯•æ—¥å¿—æ¸…ç†å™¨
 * ä¸“é—¨æ¸…ç†ç”Ÿäº§ç¯å¢ƒä¸éœ€è¦çš„è°ƒè¯•æ—¥å¿—
 */
export class DebugCleaner {
  constructor(options = {}) {
    this.options = {
      dryRun: false,  // æ˜¯å¦åªæ˜¾ç¤ºå°†è¦åˆ é™¤çš„è¡Œ
      backup: true,   // æ˜¯å¦åˆ›å»ºå¤‡ä»½
      preserveComments: true, // æ˜¯å¦ä¿ç•™é‡è¦çš„æ³¨é‡Š
      ...options
    };

    // éœ€è¦æ¸…ç†çš„æ¨¡å¼
    this.patterns = [
      // console.log è°ƒè¯•æ—¥å¿—
      /console\.log\s*\(\s*['"][^'"]*['"][^)]*\)/g,
      /console\.log\s*\([^)]*DEBUG[^)]*\)/g,
      /console\.log\s*\([^)]*debug[^)]*\)/g,

      // console.warn è°ƒè¯•æ—¥å¿—
      /console\.warn\s*\(\s*['"][^'"]*åŠ è½½.*å¤±è´¥[^'"]*['"][^)]*\)/g,

      // å…¶ä»–è°ƒè¯•æ¨¡å¼
      /console\.(log|warn|info|debug)\s*\(\s*['"][ğŸ”§âš ï¸âœ…âŒ][^)]*\)/g,
      /console\.(log|warn|info|debug)\s*\([^)]*åŠ è½½.*è·¯å¾„[^)]*\)/g,
      /console\.(log|warn|info|debug)\s*\([^)]*æ¨¡æ¿.*é•¿åº¦[^)]*\)/g
    ];

    // ä¿ç•™çš„é‡è¦æ—¥å¿—æ¨¡å¼
    this.preservePatterns = [
      /console\.log\s*\([^)]*æœåŠ¡å™¨å¯åŠ¨[^)]*\)/g,
      /console\.log\s*\([^)]*API.*æœåŠ¡å™¨[^)]*\)/g,
      /console\.warn\s*\([^)]*è­¦å‘Š[^)]*\)/g,
      /console\.error\s*\([^)]*é”™è¯¯[^)]*\)/g
    ];

    this.stats = {
      filesProcessed: 0,
      linesRemoved: 0,
      errors: 0
    };
  }

  /**
   * æ¸…ç†æŒ‡å®šç›®å½•ä¸­çš„è°ƒè¯•æ—¥å¿—
   * @param {string} dirPath - ç›®å½•è·¯å¾„
   * @param {Array<string>} extensions - æ–‡ä»¶æ‰©å±•å
   * @returns {Promise<Object>} æ¸…ç†ç»Ÿè®¡
   */
  async cleanDirectory(dirPath, extensions = ['.js']) {
    const files = await this.findJavaScriptFiles(dirPath, extensions);

    console.log(`ğŸ§¹ å¼€å§‹æ¸…ç†è°ƒè¯•æ—¥å¿—ï¼Œå…±æ‰¾åˆ° ${files.length} ä¸ªæ–‡ä»¶...`);

    for (const filePath of files) {
      try {
        await this.cleanFile(filePath);
        this.stats.filesProcessed++;
      } catch (error) {
        console.error(`âŒ æ¸…ç†æ–‡ä»¶å¤±è´¥: ${filePath}`, error.message);
        this.stats.errors++;
      }
    }

    console.log(`âœ… è°ƒè¯•æ—¥å¿—æ¸…ç†å®Œæˆï¼`);
    console.log(`ğŸ“Š ç»Ÿè®¡ä¿¡æ¯:`);
    console.log(`   - å¤„ç†æ–‡ä»¶æ•°: ${this.stats.filesProcessed}`);
    console.log(`   - åˆ é™¤è¡Œæ•°: ${this.stats.linesRemoved}`);
    console.log(`   - é”™è¯¯æ•°: ${this.stats.errors}`);

    return this.stats;
  }

  /**
   * æ¸…ç†å•ä¸ªæ–‡ä»¶
   * @param {string} filePath - æ–‡ä»¶è·¯å¾„
   * @returns {Promise<void>}
   */
  async cleanFile(filePath) {
    // è¯»å–æ–‡ä»¶å†…å®¹
    const content = await fs.readFile(filePath, 'utf8');
    const lines = content.split('\n');

    // åˆ›å»ºå¤‡ä»½
    if (this.options.backup) {
      const backupPath = filePath + '.backup.' + Date.now();
      await fs.writeFile(backupPath, content);
    }

    // æ¸…ç†æ¯ä¸€è¡Œ
    const cleanedLines = [];
    let linesRemoved = 0;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmedLine = line.trim();

      // æ£€æŸ¥æ˜¯å¦éœ€è¦ä¿ç•™
      if (this.shouldPreserveLine(trimmedLine)) {
        cleanedLines.push(line);
        continue;
      }

      // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ é™¤
      if (this.shouldRemoveLine(trimmedLine)) {
        linesRemoved++;
        continue;
      }

      // æ¸…ç†è¡Œå†…çš„å°è°ƒè¯•ä»£ç 
      const cleanedLine = this.cleanInlineDebug(trimmedLine);
      cleanedLines.push(cleanedLine);
    }

    // å†™å…¥æ¸…ç†åçš„å†…å®¹
    const cleanedContent = cleanedLines.join('\n');

    if (!this.options.dryRun && cleanedContent !== content) {
      await fs.writeFile(filePath, cleanedContent);
    }

    if (linesRemoved > 0) {
      console.log(`ğŸ—‘ï¸  ${path.relative(process.cwd(), filePath)}: åˆ é™¤äº† ${linesRemoved} è¡Œè°ƒè¯•æ—¥å¿—`);
      this.stats.linesRemoved += linesRemoved;
    }
  }

  /**
   * æŸ¥æ‰¾JavaScriptæ–‡ä»¶
   * @param {string} dirPath - ç›®å½•è·¯å¾„
   * @param {Array<string>} extensions - æ–‡ä»¶æ‰©å±•å
   * @returns {Promise<Array<string>>} æ–‡ä»¶è·¯å¾„æ•°ç»„
   */
  async findJavaScriptFiles(dirPath, extensions) {
    const files = [];

    async function scanDirectory(currentPath) {
      try {
        const entries = await fs.readdir(currentPath, { withFileTypes: true });

        for (const entry of entries) {
          const fullPath = path.join(currentPath, entry.name);

          if (entry.isDirectory()) {
            // è·³è¿‡node_moduleså’Œ.gitç›®å½•
            if (entry.name !== 'node_modules' && entry.name !== '.git') {
              await scanDirectory(fullPath);
            }
          } else if (entry.isFile()) {
            // æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
            const ext = path.extname(entry.name);
            if (extensions.includes(ext)) {
              files.push(fullPath);
            }
          }
        }
      } catch (error) {
        console.error(`æ‰«æç›®å½•å¤±è´¥: ${currentPath}`, error.message);
      }
    }

    await scanDirectory(dirPath);
    return files;
  }

  /**
   * åˆ¤æ–­æ˜¯å¦åº”è¯¥ä¿ç•™è¡Œ
   * @param {string} line - è¡Œå†…å®¹
   * @returns {boolean} æ˜¯å¦ä¿ç•™
   */
  shouldPreserveLine(line) {
    // æ£€æŸ¥ä¿ç•™æ¨¡å¼
    for (const pattern of this.preservePatterns) {
      if (pattern.test(line)) {
        return true;
      }
    }

    // æ£€æŸ¥æ˜¯å¦æ˜¯é‡è¦æ³¨é‡Š
    if (this.options.preserveComments &&
        (line.includes('@TODO') || line.includes('@FIXME') || line.includes('@IMPORTANT'))) {
      return true;
    }

    return false;
  }

  /**
   * åˆ¤æ–­æ˜¯å¦åº”è¯¥åˆ é™¤è¡Œ
   * @param {string} line - è¡Œå†…å®¹
   * @returns {boolean} æ˜¯å¦åˆ é™¤
   */
  shouldRemoveLine(line) {
    // æ£€æŸ¥åˆ é™¤æ¨¡å¼
    for (const pattern of this.patterns) {
      if (pattern.test(line)) {
        return true;
      }
    }

    return false;
  }

  /**
   * æ¸…ç†è¡Œå†…è°ƒè¯•ä»£ç 
   * @param {string} line - è¡Œå†…å®¹
   * @returns {string} æ¸…ç†åçš„è¡Œ
   */
  cleanInlineDebug(line) {
    // ç§»é™¤è¡Œå†…çš„å°è°ƒè¯•ä»£ç 
    return line
      .replace(/console\.log\s*\(\s*['"][^'"]*['"]\s*\)\s*;?\s*$/g, '')
      .replace(/console\.log\s*\([^)]*\)\s*;?\s*$/g, '')
      .replace(/\/\/ console\.log.*/g, '')
      .replace(/\/\* console\.log.*?\*\//g, '');
  }

  /**
   * è·å–æ¸…ç†ç»Ÿè®¡
   * @returns {Object} ç»Ÿè®¡ä¿¡æ¯
   */
  getStats() {
    return { ...this.stats };
  }

  /**
   * é‡ç½®ç»Ÿè®¡
   */
  resetStats() {
    this.stats = {
      filesProcessed: 0,
      linesRemoved: 0,
      errors: 0
    };
  }
}

/**
 * æ¸…ç†è°ƒè¯•æ—¥å¿—çš„ä¾¿æ·å‡½æ•°
 * @param {string} projectPath - é¡¹ç›®è·¯å¾„
 * @param {Object} options - æ¸…ç†é€‰é¡¹
 * @returns {Promise<Object>} æ¸…ç†ç»Ÿè®¡
 */
export async function cleanDebugLogs(projectPath = process.cwd(), options = {}) {
  const cleaner = new DebugCleaner(options);
  return await cleaner.cleanDirectory(projectPath);
}

/**
 * åˆ†æè°ƒè¯•æ—¥å¿—ï¼ˆé¢„è§ˆæ¨¡å¼ï¼‰
 * @param {string} projectPath - é¡¹ç›®è·¯å¾„
 * @returns {Promise<Object>} åˆ†æç»“æœ
 */
export async function analyzeDebugLogs(projectPath = process.cwd()) {
  const cleaner = new DebugCleaner({ dryRun: true, backup: false });
  const stats = await cleaner.cleanDirectory(projectPath);

  return {
    summary: `é¡¹ç›®ä¸­å‘ç° ${stats.linesRemoved} è¡Œè°ƒè¯•æ—¥å¿—ï¼Œåˆ†å¸ƒåœ¨ ${stats.filesProcessed} ä¸ªæ–‡ä»¶ä¸­`,
    details: stats,
    recommendation: stats.linesRemoved > 0 ?
      'å»ºè®®è¿è¡Œæ¸…ç†å‘½ä»¤ç§»é™¤è°ƒè¯•æ—¥å¿—' :
      'é¡¹ç›®ä»£ç å·²ç»å¾ˆå¹²å‡€ï¼Œæ— éœ€æ¸…ç†'
  };
}

export default DebugCleaner;